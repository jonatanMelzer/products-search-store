{"ast":null,"code":"import { assertInInjectionContext, DestroyRef, effect, inject, Injector, isSignal, untracked } from '@angular/core';\nimport { isObservable, of, Subject } from 'rxjs';\nexport function rxMethod(generator, options) {\n  if (!options?.injector) {\n    assertInInjectionContext(rxMethod);\n  }\n  const injector = options?.injector ?? inject(Injector);\n  const destroyRef = injector.get(DestroyRef);\n  const source$ = new Subject();\n  const sourceSub = generator(source$).subscribe();\n  destroyRef.onDestroy(() => sourceSub.unsubscribe());\n  const rxMethodFn = input => {\n    let input$;\n    if (isSignal(input)) {\n      input$ = toObservable(input, injector);\n    } else if (isObservable(input)) {\n      input$ = input;\n    } else {\n      input$ = of(input);\n    }\n    const instanceSub = input$.subscribe(value => source$.next(value));\n    sourceSub.add(instanceSub);\n    return instanceSub;\n  };\n  rxMethodFn.unsubscribe = sourceSub.unsubscribe.bind(sourceSub);\n  return rxMethodFn;\n}\nfunction toObservable(source, injector) {\n  const subject = new Subject();\n  const watcher = effect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}","map":{"version":3,"names":["assertInInjectionContext","DestroyRef","effect","inject","Injector","isSignal","untracked","isObservable","of","Subject","rxMethod","generator","options","injector","destroyRef","get","source$","sourceSub","subscribe","onDestroy","unsubscribe","rxMethodFn","input","input$","toObservable","instanceSub","value","next","add","bind","source","subject","watcher","err","error","manualCleanup","destroy","complete","asObservable"],"sources":["/home/jonatanMelzer/products-search-store/src/lib/rx-method.ts"],"sourcesContent":["import {\n  assertInInjectionContext,\n  DestroyRef,\n  effect,\n  inject,\n  Injector,\n  isSignal,\n  Signal,\n  untracked,\n} from '@angular/core';\nimport { isObservable, Observable, of, Subject, Unsubscribable } from 'rxjs';\n\nexport type RxMethodOptions = { injector?: Injector };\n\ntype RxMethodInput<Input> = Input | Observable<Input> | Signal<Input>;\n\ntype RxMethod<Input> = ((input: RxMethodInput<Input>) => Unsubscribable) &\n  Unsubscribable;\n\nexport function rxMethod<Input>(\n  generator: (source$: Observable<Input>) => Observable<unknown>,\n  options?: RxMethodOptions\n): RxMethod<Input> {\n  if (!options?.injector) {\n    assertInInjectionContext(rxMethod);\n  }\n\n  const injector = options?.injector ?? inject(Injector);\n  const destroyRef = injector.get(DestroyRef);\n  const source$ = new Subject<Input>();\n\n  const sourceSub = generator(source$).subscribe();\n  destroyRef.onDestroy(() => sourceSub.unsubscribe());\n\n  const rxMethodFn = (input: RxMethodInput<Input>) => {\n    let input$: Observable<Input>;\n\n    if (isSignal(input)) {\n      input$ = toObservable(input, injector);\n    } else if (isObservable(input)) {\n      input$ = input;\n    } else {\n      input$ = of(input);\n    }\n\n    const instanceSub = input$.subscribe((value) => source$.next(value));\n    sourceSub.add(instanceSub);\n\n    return instanceSub;\n  };\n  rxMethodFn.unsubscribe = sourceSub.unsubscribe.bind(sourceSub);\n\n  return rxMethodFn;\n}\n\nfunction toObservable<T>(source: Signal<T>, injector: Injector): Observable<T> {\n  const subject = new Subject<T>();\n\n  const watcher = effect(\n    () => {\n      let value: T;\n      try {\n        value = source();\n      } catch (err) {\n        untracked(() => subject.error(err));\n        return;\n      }\n      untracked(() => subject.next(value));\n    },\n    { injector, manualCleanup: true }\n  );\n\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n\n  return subject.asObservable();\n}\n"],"mappings":"AAAA,SACEA,wBAAwB,EACxBC,UAAU,EACVC,MAAM,EACNC,MAAM,EACNC,QAAQ,EACRC,QAAQ,EAERC,SAAS,QACJ,eAAe;AACtB,SAASC,YAAY,EAAcC,EAAE,EAAEC,OAAO,QAAwB,MAAM;AAS5E,OAAM,SAAUC,QAAQA,CACtBC,SAA8D,EAC9DC,OAAyB;EAEzB,IAAI,CAACA,OAAO,EAAEC,QAAQ,EAAE;IACtBb,wBAAwB,CAACU,QAAQ,CAAC;;EAGpC,MAAMG,QAAQ,GAAGD,OAAO,EAAEC,QAAQ,IAAIV,MAAM,CAACC,QAAQ,CAAC;EACtD,MAAMU,UAAU,GAAGD,QAAQ,CAACE,GAAG,CAACd,UAAU,CAAC;EAC3C,MAAMe,OAAO,GAAG,IAAIP,OAAO,EAAS;EAEpC,MAAMQ,SAAS,GAAGN,SAAS,CAACK,OAAO,CAAC,CAACE,SAAS,EAAE;EAChDJ,UAAU,CAACK,SAAS,CAAC,MAAMF,SAAS,CAACG,WAAW,EAAE,CAAC;EAEnD,MAAMC,UAAU,GAAIC,KAA2B,IAAI;IACjD,IAAIC,MAAyB;IAE7B,IAAIlB,QAAQ,CAACiB,KAAK,CAAC,EAAE;MACnBC,MAAM,GAAGC,YAAY,CAACF,KAAK,EAAET,QAAQ,CAAC;KACvC,MAAM,IAAIN,YAAY,CAACe,KAAK,CAAC,EAAE;MAC9BC,MAAM,GAAGD,KAAK;KACf,MAAM;MACLC,MAAM,GAAGf,EAAE,CAACc,KAAK,CAAC;;IAGpB,MAAMG,WAAW,GAAGF,MAAM,CAACL,SAAS,CAAEQ,KAAK,IAAKV,OAAO,CAACW,IAAI,CAACD,KAAK,CAAC,CAAC;IACpET,SAAS,CAACW,GAAG,CAACH,WAAW,CAAC;IAE1B,OAAOA,WAAW;EACpB,CAAC;EACDJ,UAAU,CAACD,WAAW,GAAGH,SAAS,CAACG,WAAW,CAACS,IAAI,CAACZ,SAAS,CAAC;EAE9D,OAAOI,UAAU;AACnB;AAEA,SAASG,YAAYA,CAAIM,MAAiB,EAAEjB,QAAkB;EAC5D,MAAMkB,OAAO,GAAG,IAAItB,OAAO,EAAK;EAEhC,MAAMuB,OAAO,GAAG9B,MAAM,CACpB,MAAK;IACH,IAAIwB,KAAQ;IACZ,IAAI;MACFA,KAAK,GAAGI,MAAM,EAAE;KACjB,CAAC,OAAOG,GAAG,EAAE;MACZ3B,SAAS,CAAC,MAAMyB,OAAO,CAACG,KAAK,CAACD,GAAG,CAAC,CAAC;MACnC;;IAEF3B,SAAS,CAAC,MAAMyB,OAAO,CAACJ,IAAI,CAACD,KAAK,CAAC,CAAC;EACtC,CAAC,EACD;IAAEb,QAAQ;IAAEsB,aAAa,EAAE;EAAI,CAAE,CAClC;EAEDtB,QAAQ,CAACE,GAAG,CAACd,UAAU,CAAC,CAACkB,SAAS,CAAC,MAAK;IACtCa,OAAO,CAACI,OAAO,EAAE;IACjBL,OAAO,CAACM,QAAQ,EAAE;EACpB,CAAC,CAAC;EAEF,OAAON,OAAO,CAACO,YAAY,EAAE;AAC/B"},"metadata":{},"sourceType":"module","externalDependencies":[]}